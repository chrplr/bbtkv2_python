# Time-stamp: <2022-04-19 10:04:14 christophe@pallier.org>

#    Python moddule to communicate with the BlackBox ToolKit v2
#    Copyright (C) 2014-2022  Christophe Pallier <christophe@pallier.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses
"""Interface to the Blackbox Toolkit version 2 (BBTKv2)

The **BlackBox ToolKit v2** is a device that allows psychologists to
accurately measure the timing of audio-visual stimuli (see
https://www.blackboxtoolkit.com/bbtkv2.html).

The device communicates via a serial protocol over USB. The present
module encapsulates (most of) the commands described in the *API
Guide* allowing to control the BBTKv2.

"""

import serial
import time
import sys
import re
import numpy as np
import pandas as pd
import toml

##############################################################################

DEFAULT_CONFIG = """
serialport="/dev/ttyACM0"
baudrate=57600
debug=1

[thresholds]
Mic1=100
Mic2=0
Sounder1=63
Sounder2=63
Opto1=110
Opto2=0
Opto3=0
Opto4=0

[smoothing]
smoothing='11000011'
"""

CRLF = '\r\n'
WT = 0.05  # waiting time (50 ms) between writes on serial port

################################################################################
# Fonctions to parse the outputs of the bbtkv2 commands

INPUT_PORT_NAMES = ('Keypad4', 'Keypad3', 'Keypad2', 'Keypad1', 'Opto4',
                    'Opto3', 'Opto2', 'Opto1', 'TTLin2', 'TTLin1', 'Mic2',
                    'Mic1')

OUTPUT_PORT_NAMES = ('ActClose4', 'ActClose3', 'ActClose2', 'ActClose1',
                     'TTLout2', 'TTLout1', 'Sounder2', 'Sounder1')

DSC_LINE_NAMES = ['timestamp'
                  ] + list(INPUT_PORT_NAMES) + list(OUTPUT_PORT_NAMES)


def inp_port_mask12_to_series(mask12):
    """Convert a string of bits representing the INPUT port states into a pandas.Series.
    """
    assert type(mask12) is str
    assert len(mask12) == 12
    return pd.Series([int(b) for b in mask12], index=INPUT_PORT_NAMES)


def out_port_mask8_to_series(mask8):
    """Convert a string of bits representing the OUPUT port states into a pandas.Series.
    """
    assert type(mask8) is str
    assert len(mask8) == 8
    return pd.Series([int(b) for b in mask8], index=OUTPUT_PORT_NAMES)


def capture_output_to_dataframe(text):
    """Convert the fixed record format output off the DSCM command into a pandas dataframe.

    Example of text generated by DSCM::
  
        SDAT;
        3;   # number of line changes
        30000000;  # runtime duration in micros
        120000;  # number of measurements taken
        11001100110001010101000000123456;
        01001100110001010101000000234567;
        11001100110001010101000000345678;
        EDAT;

    :param text: string containing ';' separated lines with 32 digits.

    :return: a dataframe with 21 columns: time-stamp (in milliseconds)
             followed by twenty bit values representing the states of the input/output ports.
    """
    all_events = []
    for row in text.split(';'):
        line = row.strip()
        if len(line) == 32:
            time_stamp = int(line[20:]) / 1000.0  # convert to msec
            all_events.append([time_stamp] + [int(b) for b in line[:20]])

    return pd.DataFrame(all_events, columns=DSC_LINE_NAMES)


def locate_edges(binary_sequence):
    """Find the positions of leading and falling edges in a binary sequence and
    report the onsets and durations of associated events.

    :param binary_sequence: a sequence of 0s and 1s (int)
    :return: two lists of integers corresponding to indices of raising and falling edges
    """
    if isinstance(binary_sequence, (list, pd.core.series.Series)):
        binary_sequence = np.array(binary_sequence)
    if len(binary_sequence) <= 2:
        return None, None
    assert binary_sequence[
        0] == 0  # check that the signal is at baseline when starting
    assert binary_sequence[
        -1] == 0  # check that the signal returned to baseline at the end
    leading_edges = 1 + np.flatnonzero((binary_sequence[:-1] == 0)
                                       & (binary_sequence[1:] == 1))
    falling_edges = 1 + np.flatnonzero((binary_sequence[:-1] == 1)
                                       & (binary_sequence[1:] == 0))
    return leading_edges, falling_edges


def capture_dataframe_to_events(raw_events):
    """Convert a “raw events” dataframe containing line changes into a dataframe
    with three columns: Event type, Onset time and Duration.

    :param sc_df: DataFrame containing timestamps and On/Off values for sensors
    :return: DataFrame containing onset times of leading edges of events and their durations

    """
    # set all lines to 0 at the first row to pretend we are at baseline and avoid
    # a crash in the detection of raising edges.
    raw_events.iloc[0] = 0.0

    df_list = []
    for col_name in list(set(raw_events.columns) & set(INPUT_PORT_NAMES)):
        start, end = locate_edges(raw_events[col_name])
        if len(start) != 0:
            df_list.append(
                pd.DataFrame({
                    'Type':
                    col_name,
                    'Onset':
                    raw_events.timestamp[start].values,
                    'Duration':
                    raw_events.timestamp[end].values -
                    raw_events.timestamp[start].values
                }))

    return pd.concat(df_list, ignore_index=True)


class BlackBoxToolKit:
    """Interface to a [BlackBox ToolKit v2 device](https://www.blackboxtoolkit.com/bbtkv2.html).
    """
    def __init__(self, config_file=None, config_string=None):
        """Open the serial port associated to the BBTKv2 and sets the input sensor_thresholds.

        :param config_file: filename of a toml file containing the configuration.

        Example of a ``bbtkv2.toml`` configuration file:

        .. code-block:: TOML

             serialport="/dev/ttyACM0"
             baudrate=230400
             debug=1

             [thresholds]
             Mic1=0
             Mic2=0
             Sounder1=0
             Sounder2=0
             Opto1=110
             Opto2=110
             Opto3=110
             Opto4=110

             [smoothing]
             smoothing='11000011'

        :param config_string: parameters listed in a string respecting toml syntax

        """
        if config_file is not None:
            self.settings = toml.load(config_file)
        elif config_string is not None:
            self.settings = toml.loads(config_string)
        else:
            self.settings = toml.loads(DEFAULT_CONFIG)

        self.debug = self.settings['debug'] == 1

        if self.debug:
            print("** BBTK Settings:\n\n", toml.dumps(self.settings))

        self.bbtk = serial.Serial(port=self.settings['serialport'],
                                  baudrate=self.settings['baudrate'],
                                  bytesize=serial.EIGHTBITS,
                                  parity=serial.PARITY_NONE,
                                  stopbits=serial.STOPBITS_ONE,
                                  timeout=1,
                                  xonxoff=False,
                                  rtscts=False,
                                  dsrdtr=False,
                                  writeTimeout=1)

        self.connect()
        self.write_thresholds(self.settings['thresholds'])
        self.write_smoothing(self.settings['smoothing']['smoothing'])
        self.global_data = ""

    def get_current_settings(self):
        """Get the settings stored in the bbtkv2 object (not on the BBTKv2 device!).

        :return: a dist containing the parameters and their values.
        """
        return self.settings

    def set_debug_on(self):
        """When debug is 'on', the input/output messages on the serial port are printed on the console."""
        self.settings['debug'] = 1

    def set_debug_off(self):
        """When debug is 'off', keep quiet."""
        self.settings['debug'] = 0

    def get_settings_from_toml_file(self, config_file):
        """Read settings from a file and apply them.

        :param config_file: filename of a toml file containing the configuration.

        Example of a ``bbtkv2.toml`` configuration file:

        .. code-block:: TOML

             serialport="/dev/ttyACM0"
             baudrate=230400
             debug=1

             [thresholds]
             Mic1=0
             Mic2=0
             Sounder1=63
             Sounder2=63
             Opto1=110
             Opto2=0
             Opto3=0
             Opto4=0

             [smoothing]
             smoothing='11000011'
        """
        self.settings = toml.load(config_file)

    def connect(self):
        """Initiate a connection to the BBTKv2.
        """
        self.send_break()
        self.send_command('CONN')
        resp = self.read_line()
        if resp != 'BBTK;':
            raise Exception('Cannot connect to BBTK ')
        time.sleep(1)  # wait for 1 s

    def send_break(self):
        """Send a break to the BBTK, requiring it to perform a soft reset.
        """
        if (self.debug):
            print('Sending a break to the BBTK')
        self.bbtk.sendBreak()

    def disconnect(self):
        """Close the serial connection to the BBTKv2.
        """
        self.bbtk.close()

    def is_alive(self):
        """Check if the BBTKv2 is responsive.
        """
        self.send_command('ECHO')
        return self.read_line() == 'ECHO'

    def flush(self):
        """Flush the USB buffer.
        """
        self.send_command('FLUS')
        time.sleep(2)

    def send_command(self, cmd):
        """write ``cmd`` on the serial port, then send a CR+LF.

        :param cmd: command to send
        :type cmd: string
        """
        if self.debug:
            print('Sending: ' + cmd)
        self.bbtk.write((cmd + CRLF).encode())
        time.sleep(WT)

    def get_response(self, timeout=5):
        """Accumulates characters from the serial channel, for a certain duration.

        :param timeout: time during which to wait for messages from the bbtkv2.

        :return:  the text sent by the BBTLv2.
        """
        last_time = time.time()
        data_str = ""
        self.global_data = ""
        while (self.bbtk.is_open and ((time.time() - last_time) < timeout)):
            if (self.bbtk.in_waiting > 0):
                chars = self.bbtk.read(self.bbtk.in_waiting).decode('ascii')
                data_str += chars
                self.global_data += chars
                if self.debug:
                    print(chars, end='')
                last_time = time.time()
            time.sleep(0.05)

        return data_str

    def read_line(self):
        """Read a single line from the bbtkv2 (blocking! No timeout)

        :return: the string of characters, without the '\n'.
        """
        time.sleep(WT)
        if self.debug:
            print('Waiting for response from BBTK...')

        s = ''
        c = self.bbtk.read().decode('ascii')
        if self.debug:
            sys.stdout.write(c)

        while c != '\n':
            if c != '\n':
                s = s + c
            c = self.bbtk.read().decode()
            if (self.debug):
                sys.stdout.write(c)
        if (self.debug):
            sys.stdout.write('\n')
        return (s)

    def get_firmware_version(self):
        self.send_command('FIRM')
        return self.read_line()

    def display_info_on_bbtk_display(self):
        self.send_command('ABOU')
        time.sleep(2)

    def write_smoothing(self, mask):
        """Set smoothing to Opto and Mic sensors.

        * When smoothing is 'off', the BBTK will detect *all* leading edges, e.g.
        each refresh on a CRT.
        * When smoothing is 'on', you need to subtract 20ms from offset times.

        :param mask: a 8 binary mask ``Mic1:Mic2:Opto4:Opto3:Opto2:Opto1:NA:NA``

        :type mask: str
        """
        self.send_command('SMOO')
        self.send_command(mask)
        time.sleep(1)
        # return self.is_alive()

    #  TODO: implement fine grained manipulation of smoothing bits
    # def set_crt_smoothing(self):
    #     self.smothing
    #     self.send_command('SMOO')
    #     self.send_command('00111111')
    #     return self.is_alive()

    # def unset_crt_smoothing(self):
    #     self.send_command('SMOO')
    #     self.send_command('00000011')
    #     return self.is_alive()

    # def set_mic_smoothing(self):
    #     self.send_command('SMOO')
    #     self.send_command('11000011')
    #     return self.is_alive()

    # def unset_mic_smoothing(self):
    #     self.send_command('SMOO')
    #     self.send_command('00000011')
    #     return self.is_alive()

    def write_thresholds(self, thresholds=None):
        """Send thresholds to the BBTKv2, and saves tham in settings

        :param thresholds: dictionary {name: value (int between 0 and 127)}

        :return: bool (True=the bbtk is alive; False: something wrong occurred, check.)
        """
        if thresholds is None:
            thresholds = self.settings['thresholds']
        else:
            self.settings['thresholds'] = thresholds

        self.send_command("SEPV")
        self.send_command(str(thresholds['Mic1']))
        self.send_command(str(thresholds['Mic2']))
        self.send_command(str(thresholds['Sounder1']))
        self.send_command(str(thresholds['Sounder2']))
        self.send_command(str(thresholds['Opto1']))
        self.send_command(str(thresholds['Opto2']))
        self.send_command(str(thresholds['Opto3']))
        self.send_command(str(thresholds['Opto4']))
        time.sleep(1)
        return self.is_alive()

    def read_thresholds(self):
        """Read the values of the 8 input sensor thresholds.

        :return: a dict {name: value (int between 0 and 127)}
        """
        self.send_command('GEPV')
        time.sleep(0.5)
        resp = self.read_line()
        values = [int(x) for x in re.findall('\d+', resp)]
        assert len(values) == 8
        levels = {
            'Mic1': values[0],
            'Mic2': values[1],
            'Sounder1': values[2],
            'Sounder2': values[3],
            'Opto1': values[4],
            'Opto2': values[5],
            'Opto3': values[6],
            'Opto4': values[7]
        }
        self.settings['thresholds'] = levels
        return levels

    def adjust_thresholds(self):
        self.send_command('AJPV')
        response = ''
        while response != 'Done;':
            response = self.read_line()
        self.read_thresholds()

    def clear_timing_data(self):
        self.send_command('SPIE')
        while self.read_line() != 'DONE;':
            time.sleep(1)

    def input_line_check(self, duration=5):
        """Detect events on the input line and print them.

        :param duration: duration before sending soft break, in s
        :type duration: int

        :return: None
        """
        self.send_command('ICHK')
        start_time = time.time()
        while time.time() - start_time < duration:
            resp = self.read_line()
            print(resp)

    def output_lines_check(self, mask):
        """Send a pattern to the 8 output lines ('ActClose4', 'ActClose3', 'ActClose2', 'ActClose1',
        'TTLout2', 'TTLout1', 'Sounder2', 'Sounder1').

        :param mask: 8 bits mask
        :type mask: str

        :return: None

        To interrupt a sounder, set its bit to 0 or call ``send_break()``

        """
        self.send_command('OCHK')
        self.send_command(mask)

    def capture(self, duration=10, output_file='raw_DSCM_output.txt'):
        """Launches a digital data capture session.

        :param duration:  duration of acquisition in seconds
        :type duration: int

        :return: the text output by the DSCM command
        """
        # self.clear_timing_data()
        # time.sleep(5)
        self.send_command('DSCM')
        self.send_command('TIML')
        self.send_command(str(duration * 1000000))
        time.sleep(.5)
        self.send_command('RUDS')
        time.sleep(duration)
        text = self.get_response(5)
        if output_file is not None:
            with open(output_file, 'wt') as f:
                f.write(text)

        lines = text.split('\n')
        assert lines[1]=='SDAT;'
        nevents = lines[2]
        capture_time = lines[3]
        nsamples = lines[4]
        events = lines[5:-2]
        print("Total number of events=", len(events))
        return text

    def event_generation_pulse_train(self,
                                     timings=[
                                         '100,1000,00000001',
                                         '100,1000,00000000'
                                     ]):
        self.send_break()
        time.sleep(.5)
        self.send_command('PRPT')
        self.send_command('TIML')
        self.send_command('0')
        for row in timings:
            self.send_command(row)

        self.send_command('PCPT')
        self.send_command('RUPT')
        # now the program will run until a break is sent to the bbtkv2


def test_acquisition():
    """Launches a capture for ~30s, prints and save the events detected on the input lines.

    .. warning::
       You may have to adjust the sensor thresholds, e.g. in the variable DEFAULT_SETTINGS.
       Alternatively, if you run in a interactive session, you can use the methd ``adjust_sensors_levels()``
       to set the thresholds with the knob on the BBTKv2.
    """
    bb = BlackBoxToolKit()
    time.sleep(1)
    # bb.adjust_thresholds()
    bb.clear_timing_data()
    time.sleep(2)
    print("You have 15 seconds to generate events...")
    text = bb.capture(15)
    raw_events = capture_output_to_dataframe(text)
    raw_events.to_csv('dscm_raw_events.csv')
    processed_events = capture_dataframe_to_events(raw_events)
    print(processed_events)
    processed_events.to_csv('dscm_processed_events.csv')


if __name__ == '__main__':
    test_acquisition()
